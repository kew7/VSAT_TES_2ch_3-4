В интерфейсе драйвера следующие функции (интерфейс DeviceIoControl):

IOCTL-код 0х00222043  (GetData)
Функция читает данные из устройства в процесс.
Входной буфер - значение типа ULONG (длина буфера 4 байта соответственно),
	содержащее номер абстрактного канала данных, от которого нужны данные.
	ПарусМ содержит два канала (0,1) для каждого процессора.
	Посмотрите как назначаются прерывания и адреса ввода/выыода в реестре,
	и станет понятно как процессоры привязаны к каналам данных.
	Если передается неправильный канал данных DeviceIoControl вернет ошибку.
Выходной буфер любой длины принимает данные из канала.
В параметр BytesReturned DeviceIoControl возвращается число пересланных байт,
	которое может быть меньше длины выходного буфера. Это число к тому же
	всегда кратно восьми.
Особенности: Драйвер имеет внутренний буфер по 131072 байта на каждый абстрактный 
	канал данных, который заполняет устройство, используя механизм прерываний.
	Функция определяет, сколько данных доступно в соответствующем буфере и какого
	объема выходной буфер ей передан. Она заполнит весь буфер данными, если их больше,
	чем объем буфера (длина возвращаемых данных всегда кратна восьми !!!) или отдаст
	в буфер все данные в противном случае. Всегда проверяйте значение BytesReturned!
	Если внутренний буфер драйвера будет заполнен, то приходящие вновь данные будут
	теряться.


IOCTL-код 0х00222083  (GetBlock)
	То же, что и GetData, но только функция возвращает данные блоком, длинной, определяемой
	выходным буфером (длина возвращаемых данных всегда кратна восьми !!!). Если данных
	запрошенной длины еще не накоплено, то функция завершится успешно, но вернет
	данные нулевой длины. Всегда проверяйте значение BytesReturned!

IOCTL-код 0х002220с3  (GetAvailableData)
Функция определяет наполненность буферов каналов.
Входной буфер - значение типа ULONG (длина буфера 4 байта соответственно),
	содержащее номер абстрактного канала данных, от которого нужны данные.
Входной буфер - значение типа ULONG (длина буфера 4 байта соответственно),
	куда записывается число байт во внутреннем буфере драйвера соответствующего
	канала. 
Особенности: не ошибитесь в длинах и значения параметров, иначе функция завершится
	с ошибкой.

IOCTL-код 0х00222103  (FlushData)
Функция очищает от данных внутренние буфера драйвера для соответствующего канала.
Входной буфер - значение типа ULONG (длина буфера 4 байта соответственно),
	содержащее номер абстрактного канала данных.
Входной буфер - NULL,0

IOCTL-код 0х00222140  (LoadUnit)
Функция загружает какую либо микросхему устройства.
Входной буфер - содержит дамп загрузки микросхемы, который начинается заголовком
	из четырех байт или значение типа ULONG. Заголовок содержит номер микросхемы 
	(номера микросхем определяются кодом драйвера).	Для ПарусаМ: 0 - процессор 0,
	 1 - процессор 1(Для Миража 0 - процессор, 1 - ПЛИС). Посмотрите как назначаются прерывания, адреса ввода/выыода 
	в реестре и принципиальную схему устройства, и станет понятно как процессоры 
	привязаны к своим номерам.
	Длина буфера = длина дампа в байтах + 4
Входной буфер - NULL,0
Особенности: не ошибитесь в длинах и значения параметров, иначе функция завершится
	с ошибкой. Эта функция завершается с ошибкой STATUS_IO_TIMEOUT, если микросхема
	по каким либо причинам не загружается.

IOCTL-код 0х00222180  (TotalReset)
Функция сбрасывает все, что можно сбросить на плате и в драйвере.
Входной буфер - все, что хотите (не проверяется).
Выходной буфер - все, что хотите (не проверяется).
Особенности: функция вызывается внутри драйвера в ответ на закрытие его Handle.
	Будте внимательны при неоднократном открыти и закрытии драйвера разными 
	приложениями.

IOCTL-код 0х002221c0  (CheckUnit)
Функция предназначена для проверки железа на плате, но в данном релизе не реализована.
	Всегда возвращает STATUS_SUCCESS.
	Будут рассмотрены все предложения относительно реализации этой функции.
	

	Handle устройства можно использовать с фунциями ReadFile WriteFile.
	Конкретно этот драйвер совершенно одинаково реагирует на оба вызова (рассматривать 
	как синонимы). Эти функции реализуют чтение и запись пространства ввода/вывода
	в любых сочетаниях. В этих операциях используется понятие элементарной посылки,
	которая описывается стуктурой длиной в шесть байт: 
				typedef struct ParcelTag{
					ULONG Port 	   :8;
					ULONG DataChannel  :5;
					ULONG Width	   :3;
					ULONG Delay 	   :15;
					ULONG ReadWrite	   :1;
					ULONG Reserv;
					ULONG Value;
				}PortParcel;
	Port - байтовое смещение от базового порта. Если превышает окно ввода/вывода -
	- функция прерывается и возвращает ошибку.
	DataChannel - номер абстрактного канала данных, которому соответствует окно
	ввода/вывода.
	Width - размерность данных для операций чтения/записи: 0 - 32 бита, 1 - 16 бит,
	2 - 8 бит. 
	Delay - число микросекунд задержки после выполнения операции.
	ReadWrite - 0 - чтение, 1 - запись.
	Reserv - зарезервировано (должно содержать 0)
	Value - значение для записи или прочитанное значение.
	Массив из этих структур отдается как буфер в ReadFile или WriteFile.
Особенности: все параметры во всех посылках проверяются. Если какой либо параметр не есть
	правильный - функция прерывает цепочку операций и возвращает ошибку. Однако
	часть успешно обработанного буфера можно использовать (если нужны прочитанные 
	значения).

IOCTL-код 0х00222203  (SetAcknowledgement)
	В некоторых устройствах нужно на каждое прерывание выставлять 
	подтверждение посредством записи данных в определенный порт устройства.
	Данные, которые приэтом будут записываться можно установить этой 
	функцией.
Входной буфер - два значения типа ULONG. Первое - абстрактный канал данных.
	Второе - непосредственно данные.
Выходной буфер - NULL.
Особенности: по умолчанию для всех каналов данных подтверждение установлено в 0.

IOCTL-код 0х00222400  (GetDriverInfo) - implemented only in driver version 2
Функция получает информацию о драйвере в выходном буфере. 
Входной буфер  - NULL. 
Выходной буфер - long[4]:
		[0] - объем буфера в драйвере в байтах.
		[1] - старшая половина - номер версии, младшая - уточнение номера версии
		[2] и [3] - зарезервировано (нули)

IOCTL-код 0х00222243  (Pipe)
Функция осуществляет обмен командами и уведомлениями как от 
	приложения к драйверу, так и от драйвера к приложению посредством
	объекта ядра "событие". 
Входной буфер длиной  8 байт - содержит два числа int32. Первое - 
	код сообщения, второе - данные сообщения. 
Выходной буфер такой же.
	Коды сообщений - формализованы и не меняются от версии к версии. 
	Набор кодов может увеличиваться с ростом номера версии драйвера. 
	Работает этот канал следующим образом:
	1. Приложение вызывает CreateEvent для создания объекта "событие".
	2. Приложение переводит событие в несигнальное состояние.
	3. Вызывается DeviceIoControl с функцией Pipe, где во входном
	буфере отдается код сообщения 10 (PIPE_INIT) со значением HANDLE,
	возвращаемое CreateEvent. Таким же образом отдаются другие коды 
	сообщений.
	4. Приложение формирует поток опроса, синхронизируемый этим событием.
	5. Приложение отсылает код сообщения 20 (PIPE_TEST)
	6. Поток опроса на перевод события, его синхронизирующее 
	в сигнальное состояние разрешается для выполнения и опрашивает драйвер 
	отсылая код сообщения 30 (PIPE_GET_MESSAGE) и получает в выходном буфере DeviceIoControl
	код сообщения 100 (PIPE_MESSAGE_NOMESSAGE).
	7. Поток опроса после обработки сообщения переводит событие в 
	несигнальное состояние, тем самым приостанавливая себя.
	8. Далее посредством этого механизма драйвер может уведомлять 
	приложение, передовая коды сообщений.
	9. По окончании работы приложение удаляет событие и передает
	в драйвер PIPE_INIT со значением NULL.
	
	Стандартные значения сообщений, передаваемых по событию
        Входные сообщения:
	#define PIPE_INIT	 10  
	 Передает HANDLE события в драйвер. Поле данных сообщения - HANDLE
	 события для его установки и NULL для снятия.
	#define PIPE_TEST	 20   
	 Просит драйвер продуть канал (выставить событие с кодом 
	 PIPE_MESSAGE_NOMESSAGE), поле данных не используется.
	#define PIPE_GET_MESSAGE 30  
	 Просит драйвер доложить о причине установки события в сигнальное 
	 состояние. Поле данных не используется. Код причины (выходные 
	 сообщения) передаются в выходном  буфере.  
	Выходные сообщения:
	#define PIPE_MESSAGE_NOMESSAGE	100  
	 Драйвер ничего не говорит (Пустое либо проверочное сообщение).
	 Поле данных не используется.
	#define PIPE_MESSAGE_OVERFLOW	110  
	 Драйвер говорит о переполнении внутреннего FIFO. Поле данных
	 не используется.
	#define PIPE_MESSAGE_OK		120   
	 Драйвер говорит ДА. Поле данных не используется.
	#define PIPE_MESSAGE_CANCEL	130   
	 Драйвер говорит НЕТ. Поле данных не используется.